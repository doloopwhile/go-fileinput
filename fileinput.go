// An analogous article of fileinput module in Python
//
// Examples:
//
//    // reverse.go
//    // print file lines in reverse order.
//    package main
//
//    import (
//    	"fmt"
//    	"os"
//
//    	"github.com/doloopwhile/go-fileinput"
//    )
//
//    func main() {
//    	sc := fileinput.Lines(os.Args[1:])
//    	lines := []string{}
//    	for sc.Scan() {
//    		l := sc.Text()
//    		lines = append(lines, l)
//    	}
//    	if sc.Err() != nil {
//    		os.Stderr.WriteString(sc.Err().Error() + "\n")
//    		os.Exit(1)
//    	}
//    	for i := len(lines) - 1; i >= 0; i-- {
//    		fmt.Printf("%02d: %s\n", i+1, lines[i])
//    	}
//    }
package fileinput

import (
	"bufio"
	"io"
	"os"
)

// Lines returns a new Scanner to read lines of files in args.
// If args is empty, it return a Scanner which scans os.Stdin.
func Lines(args []string) *Scanner {
	if len(args) == 0 {
		args = []string{"-"}
	}
	return &Scanner{
		Args: args,
		Open: StdOpen,
	}
}

type (
	// Scanner provides a interface like bufio.Scanner
	// to reading data from multiple files.
	//
	// It is not expected that members of Scanner is modified after first call of .Scan()
	// If it was, it is undefined what happen.
	Scanner struct {
		Args      []string                                 // Names of files. It should be os.Args[1:] in typical use case.
		Open      func(name string) (io.ReadCloser, error) // Function to open files.
		SplitFunc bufio.SplitFunc                          // Argument of Split() of bufio.Split.

		sc       *bufio.Scanner
		rc       io.ReadCloser
		icurr    int
		err      error
		filename string
		lineNo   int
		closed   bool
	}
)

// Scan advances internal scanner to the next token like Scan method of bufio.Scanner.
// It automatically open/close files specified in Args.
func (s *Scanner) Scan() bool {
	if s.closed {
		return false
	}
	for s.icurr < len(s.Args) {
		if s.err != nil {
			return false
		}

		if s.sc == nil {
			s.rc, s.err = s.Open(s.Args[s.icurr])
			if s.err != nil {
				return false
			}
			s.sc = bufio.NewScanner(s.rc)
			if s.SplitFunc != nil {
				s.sc.Split(s.SplitFunc)
			}
			s.filename = s.Args[s.icurr]
		}

		r := s.sc.Scan()
		s.err = s.sc.Err()
		if r {
			s.lineNo++
			return true
		}
		s.Next()
	}
	return false
}

// Next close current file and so that the next iteration will read the first line from the next file (if any).
func (s *Scanner) Next() {
	if s.closed {
		return
	}
	if s.rc != nil {
		err := s.rc.Close()
		if s.err == nil {
			s.err = err
		}
		s.rc = nil
		s.sc = nil
	}
	s.icurr++
}

// Text returns the most recent token generated by a call to Scan as a newly allocated string holding its bytes.
func (s *Scanner) Text() string {
	if s.err != nil || s.closed || s.sc == nil {
		return ""
	}
	return s.sc.Text()
}

// Err returns the first non-EOF error
// that was encountered by the Scanner or was returned by Open.
func (s *Scanner) Err() error {
	return s.err
}

// Filename return the name of the file currently being read.
// Before the first line has been read, returns empty string.
func (s *Scanner) Filename() string {
	return s.filename
}

// LineNo returns the cumulative line number of the line just read.
func (s *Scanner) LineNo() int {
	return s.lineNo
}

// Close closes the Scanner.
func (s *Scanner) Close() error {
	alreadyErr := (s.err != nil)
	s.Next()
	if alreadyErr {
		return nil
	}
	return s.err
}

// StdOpen open file with os.Open. However, it returns os.Stdin for "-".
func StdOpen(name string) (io.ReadCloser, error) {
	if name == "-" {
		return os.Stdin, nil
	}
	return os.Open(name)
}
